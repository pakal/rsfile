{\rtf1\ansi\ansicpg1252\uc1\deff0\stshfdbch0\stshfloch0\stshfhich0\stshfbi0\deflang1036\deflangfe1036{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f35\fswiss\fcharset0\fprq2{\*\panose 020b0604030504040204}Tahoma;}{\f36\froman\fcharset238\fprq2 Times New Roman CE;}{\f37\froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f39\froman\fcharset161\fprq2 Times New Roman Greek;}{\f40\froman\fcharset162\fprq2 Times New Roman Tur;}{\f41\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f42\froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\f43\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f44\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f56\fmodern\fcharset238\fprq1 Courier New CE;}{\f57\fmodern\fcharset204\fprq1 Courier New Cyr;}
{\f59\fmodern\fcharset161\fprq1 Courier New Greek;}{\f60\fmodern\fcharset162\fprq1 Courier New Tur;}{\f61\fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f62\fmodern\fcharset178\fprq1 Courier New (Arabic);}
{\f63\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f64\fmodern\fcharset163\fprq1 Courier New (Vietnamese);}{\f386\fswiss\fcharset238\fprq2 Tahoma CE;}{\f387\fswiss\fcharset204\fprq2 Tahoma Cyr;}{\f389\fswiss\fcharset161\fprq2 Tahoma Greek;}
{\f390\fswiss\fcharset162\fprq2 Tahoma Tur;}{\f391\fswiss\fcharset177\fprq2 Tahoma (Hebrew);}{\f392\fswiss\fcharset178\fprq2 Tahoma (Arabic);}{\f393\fswiss\fcharset186\fprq2 Tahoma Baltic;}{\f394\fswiss\fcharset163\fprq2 Tahoma (Vietnamese);}
{\f395\fswiss\fcharset222\fprq2 Tahoma (Thai);}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;
\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 \snext0 Normal;}{\*\cs10 \additive \ssemihidden Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1024\langfe1024\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}{\s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \cbpat9 
\f35\fs20\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 \sbasedon0 \snext15 \ssemihidden \styrsid6238528 Document Map;}}{\*\latentstyles\lsdstimax156\lsdlockeddef0}{\*\rsidtbl \rsid6238528}{\*\generator Microsoft Word 11.0.5604;}{\info
{\title TO BE MOVED TLO RSFILE INDEX}{\author Pakal}{\operator Pakal}{\creatim\yr2010\mo2\dy24\hr20\min28}{\revtim\yr2010\mo2\dy24\hr20\min28}{\version2}{\edmins0}{\nofpages7}{\nofwords3040}{\nofchars16725}{\nofcharsws19726}{\vern24689}}
\margl1417\margr1417\margt1417\margb1417 \deftab708\widowctrl\ftnbj\aenddoc\hyphhotz425\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3
\jcompress\viewkind4\viewscale105\nolnhtadjtbl\rsidroot6238528 \fet0\sectd \linex0\sectdefaultcl\sftnbj {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3
\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}
{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain 
\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \fs24\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 {\f2\fs20\insrsid6238528 
\par 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\outlinelevel0\rin0\lin0\itap0\pararsid6238528 {\f2\fs20\insrsid6238528 TO BE MOVED TLO RSFILE INDEX!!!!!
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\lang2057\langfe1036\langnp2057\insrsid6238528 
rsFile aims at providing python with a cross-platform, reliable, and comprehensive file I/O API (that is, file stream manpulation, not filesystem operations like shutil does). Stdlib file stream APIs suffer indeed from their history and their C/unix origi
ns : they are scattered all over lots of modules (os, stat, fnctl???, tempfile...), poorly object-oriented, full of platform-specific behaviours, and worst of all they sometimes rely on castrated implementations, like windows' libc compatibility layer.

\par That's why rsFile offers more than a simple interfacing/adaptation layer : it also wraps native file objects (like win32 "Handles"), to ensure a maximal flexibility ro the API.
\par }{\f2\fs20\insrsid6238528 The main idea behind the design of the API, is that "cross-platform" doesn't mean "
lowest denominator", and that "high level" doesn't mean "poor". That's why, even though rsFile can transparently replace the current python builtin file object, it also provides lots of additional methods and parameters to finely tweak the streams you nee
d : file chunk locking, timeout handling, disk synchronization, atomic file creation, handle inheritance, thread safety...
\par 
\par 
\par The development of rsfile, which was initially supposed to be quite quick and straightforward, revealed himself like a long series of hits against walls, due to numerous and little know gotchas and platform-specific weirdnesses.
\par 
\par 
\par Locking Recursivity :
\par The thread-level lock included in the rsFile is always recursive, i.e as threading.RLock, it allows the same thread to acquire it several times ; as long as this lock is released the same number of time as it's acquired, all will be fine.
\par But the process-level lock cannot be recursive on all platforms.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\outlinelevel0\rin0\lin0\itap0\pararsid6238528 {\f2\fs20\insrsid6238528 FALSE
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\insrsid6238528  That's why, by default, the process holding it (whathever particular thread issu
ed the acquisition call) will raise a RuntimeError if it tries to lock some bytes several times without releasing it inbetween. Also, 
\par However, it is possible to disabled this "cross-platform uniformity" by setting to "False" the registry option XXXX.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\outlinelevel0\rin0\lin0\itap0\pararsid6238528 {\f2\fs20\insrsid6238528 Advantages
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\insrsid6238528 - you gain performance by removing the overhead of this checking on posix platforms (windows ones tooo??? what happens exactly if we double lock???)
\par - you can benefit from posix's advanced locking features ( merging or separation of locked chunks 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\outlinelevel0\rin0\lin0\itap0\pararsid6238528 {\f2\fs20\insrsid6238528 This might be interesting in two particular cases
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\insrsid6238528 - your application will only run in posix system, and you 
\par /FALSE
\par 
\par 
\par If the principle of "composed streams" affords a great flexibility, it comes at the cost of losing the notion of "public method". Indeed, d
epending on the chainning of different IOBase instances, they will be directly accessible, or instead wrapped in other objects. This is particularly embarrassing concerning thread-safety : in prevision of the moment when it might be used as"top-level" obj
e
ct, each stream type currently implements its own mutex system, which is both error-prone (in the IO implementation, some methods like xxx.truncate are not thread-safe ??????), and performance-hindering (there might easily be until 3 levels of redundant l
ocking, eg. in common textIOWrapper streams).
\par To solve the problem, rsFile uses some kind of "thread-safe interface" pattern : each class inheriting IOBase shall implement its logic in a thread-unsafe way, and it's up to each factory functions (like io.open
()) to wrap the top-level object of the IO chain inside a "thread-safe adapter", a transparent wrapper which simply ensures that only one thread at a time may access the methods and properties of the stream ????
\par 
\par .. rubric::
\par \tab **some definitions**
\par 
\par Disk file : this is the set of physical disk blocks on which your file (both metadata and data) is eventually stored. This is also the only place where data can really be considered as persistent. Data is saved onto the disk file far less often than we mi
ght think - on laptops particularly, disks can be left inactive for dozens of minutes in order to preserve energy.
\par 
\par Open file object : this kernel-level object represents an open stream to a file. As such, it contains references to the target file, as well 
as transient state information relative to the open stream (current file pointer, miscellaneous caching and locking information...)
\par 
\par Open file descriptor (C file descriptor on posix systems, file handle on win32 platforms) : this type  mostly acts as a "po
inter" to an open file object. It is typically an integer used as an index in a per-process (posix) or global (win32) open file table. Several open file references can target the same open file objects, via inheritance (case of a fork()) or dedicated dupl
i
cation functions (dup() on posix, DuplicateHandle() on win32). Depending on the platform, open file descriptors have specific attributes (like permissions, locks, inheritability options...), but the rest of their "state" is the one of the open file they r
epresent (eg. duplicated file descriptors share the same file pointer)  
\par 
\par Since, in a platform-specific way, crucial safety information may be owned by open file references or by open file objects, the easiest way to unify the behaviour of high level stream
s is to prevent file descriptor duplication inside each process, and to consider "open file descriptor -> open file object" couples as inseperable entities. Since on the contrary, lots of different python objects can keep references, and write to, such hi
g
h level streams (in particular, it's trivialy to replace standard streams in sys module), this shouldn't be too cruel a constraint. However, experienced developers may still retrieve native open file references, and play with lowel level IO routines as th
ey wish - we're all consentent adults, remember ?
\par 
\par .. note:: ???aaltready said elsewhere
\par \tab file descriptor duplication will always occur when forking, since no CLOFORK semantic is available on all *nix systems. It will also happen when file descriptors get inherited But rsfile
\par \tab ??? NO - always duplication when inheeriting !!!!!
\par 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\outlinelevel0\rin0\lin0\itap0\pararsid6238528 {\f2\fs20\insrsid6238528 SAY that DESCRIPTOR != handle but well we ASSUME IT
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\insrsid6238528 Note on terminology : normally, only 'file descriptor" should be used by lowest level integer indexes pointing to open file objects
 ; 'handle' should be reserved for higher level wrappers (like C's FILE structure), adding caching or other mechanisms to the stream. But since windows uses "HANDLE" to designate its native file descriptors, we use 'file descriptor' and 'handle' interchan
geably ??? in the rest of this documentation, to designate??? low level integer indexes. Our "handles" in python are actually the high level streams like those of the io module.
\par 
\par fileno()
\par handle()
\par These methods give access to low level types underlying the rsFile streams. 
\par fileno() returns a C/Posix compatible file descriptor (actually, an integer action as index in the process file descriptor table - where 0, 1 and 2 are standard streams).
\par handle() returns a more platform-specific file handle, if any (on win32, a handle integer or a thin wrapper around it).
\par Note that if the requested object doesn't exist on the execution platform, an IOError ???? is raised.
\par 
\par 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\outlinelevel0\rin0\lin0\itap0\pararsid6238528 {\f2\fs20\insrsid6238528 PB avec fctl si on ferme differents descripteurs ????
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\insrsid6238528 
\par 
\par Inheritance of file objects between p
arent and child processes isn't a simplistic subject, especially if you want to play with different stream types (FILE*, ostream, ...) and process creation methods (spawn(), fork(), CreateProcess) on different platforms.
\par In the case of rsFile however, in which native file handles are used on each platform, a somehow unified behaviour can be obtained. By default, rsFile streams are NOT inheritable, but they can be made so at opening time. 
\par Then, to achieve inheritance, two operations must be done.
\par -Creating a new process thanks to a "certified" call.
\par On unix, the fork+exec behaviour properly takes file descriptor inheritance into account. Notte that after fork, file descriptors are ALWAYS inherited, since the forking process 
\par 
\par Note : it's a little off-topic, but I "profiter"??? of the occasion to recall that fork() and multithreading HATE each other. Basically, only the thread issuing ythe fork will be duplicated to the new process, and many data structures might be left
\par 
\par the semantic of stream inheritability can be tamed if we only use corresponding process creation methods.
\par By default, 
\par 
\par On posix platforms, where subprocess creation -> what happens when execing ??? can a fd be closed when forking ???
\par Due to the number of file types
\par 
\par 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\outlinelevel0\rin0\lin0\itap0\pararsid6238528 {\f2\fs20\insrsid6238528 Buffering and caching
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\insrsid6238528 The data we read from or write to a file actually goes through many more levels of buffering than we might think.
\par 
\par Application-level caching : This is the caching we find in C libraries (inside FILE* objects, cf setvbuf()), python file objects (via the "buffe
ring" parameters) and more generally any IO library written in a given language. It usually consists of read-ahead buffering (to improve performance, allow character encoding operations, and allow line ending detection) and write buffering (to diminish th
e number of write system calls - this buffer can be manually emptied with a flush() operation). A seek() on a stream typically resets this buffering.
\par 
\par Kernel-level caching and buffering : contrary to popular belief, if you open a file, issue read/write oper
ations on it, and close it (with an implicit flush), this doesn't implicate that your modifications have been saved to disk. Most likely, they've just been reflected by a cache located in the kernel, and will be written to oxyde later, with other changes,
 
by a lazy writer (pdfflush on linux, ....????). Since that kernel caching is fully transparent to applications (no desynchronization occurs between what different processes see in files), it usually doesn't matter. But in case of crash, data which hasn't 
eventually been written to oxyde will be lost - which can be extremly embarrassing for sensitive files management, database applications etc.
\par That's why operfating system offer ways of flushing that kernel cache, to ensure that data gets properly pushed to 
the device before starting other operations. Such a flush can be manual (posix??? sync() call, win32 FlushFileBuffers...) or enforced for each write on a given open file (O_SYNC/FILE_WRITE_THROUGH opening flags). Note that variants of that kernel cache fl
ush exist (dsync, rsinc, ...semantics), to also enforce flushes on read operations, but rsFile concentrates on the most critical requirement  - having your data become persistent when you ask it.
\par 
\par 
\par 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\outlinelevel0\rin0\lin0\itap0\pararsid6238528 {\f2\fs20\insrsid6238528 Note on Disk internal cache
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\insrsid6238528 Although all operating system 
provide ways of flushing the kernel cache to the device, this is not always sufficient. Indeed, for performance reasons, most hard disk have an internal "disk cache" enabled by default, which doesn't necessarily get flushed by sync calls. Needless to say 
t
hat your data is not much more likely to survive to a crash, if it's in the disk cache instead of the kernel one (although sophisticated disks are sometimes backed by batteries to deal with this case, and let the device automatically purge itself before f
alling out of energy).
\par So here is an overview of the "disk cache" affair:
\par - Disks and operating system easily lie abo
ut their real synchronization state. That's why, if you have very important data to protect,your best chance is to disable all disk caching features, through hardware configuration  utilities, (hdparm -W 0, windows hardware condiguration panels etc.). But
 
such tweaks can heavily hinder performance, and they heavily depend on your hardware - IDE and SCSI disks, for example, can have very different options and, and more or less "deceiving" behaviours. If your data is stored on remore shares (samba, nfs...) t
h
en chances are big that your sync calls won't make it to the oxyde, and only a careful study of involved hardware/OS/applications may give you some certainties in this case (a good old "unplug the cable violently" test might also help - see the perl utili
ty **** for that).
\par Windows : The win32 FlushFileBuffer call theoretically implicates both kernel cache and disk cache flushing, as well on local as on remote ntfs filesystem????? TO CHECK
\par *nix-like systems: as well in posix norms as in the Single Unix Specification, nothing ensures???assurer? that fsync() calls will care about disk cache. But more specifically:
\par \tab - Mac OS X users : lucky you, Apple has introduced a new fcntl flag (F_FULLSYNC) to enforce full synchronization.
\par \tab - Linux users: it seems that the very latest kernel versions (3.6.???? and above) have been patched to ensure full sync. The question is : when will that patch make it to your favorite distribution ?
\par \tab - Other *nix-like platforms : Your mileage may vary... read the sweet manuals, as we say.
\par 
\par 
\par win32:
\par LockFile:
\par This is a mandatory, per-handle, non reentrant lock, allowing byte range locking.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\outlinelevel0\rin0\lin0\itap0\pararsid6238528 {\f2\fs20\insrsid6238528 More precisely
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\insrsid6238528 \tab -once a file area is locked through a handle, no other handle, in this process or another one, can access this area in a way incompatible
 to the lock type (shared or exclusive). Forbidden read/write operations will fail immediately, incompatible locking attempts through other handles/processes will block, and trying to lock the bytes already locked through the same handle will block too ??
?
\par \tab There is no merging/cutting of locked ranges. Unlocking calls must provide as arguments a byte range identical to one of those previously locked.
\par Locks are removed automatically by the system (but possibly after some delay) when the handle is closed or the process is shut down.
\par 
\par Unix:
\par -fcntl locks, 
\par This is an advisory, per-process, rentrant lock, allowing byte range locking
\par \tab - Write or read operations which take no account of file locking will not be hindered by these locks, unless mandatory locking has been activated on this particular file (SEE DOCS\'b0
\par \tab - Inside a process, it makes no difference whether a file/range has been locked via a specific handle or open file object : the lock belongs to the whole process ; 
\par \tab - Byte range locking is very flexible :
 consecutive areas can be freed in a single unlock() call, it is possible to release only part of a byte range, and locking the same bytes several times simply updates their locking mode (exclusive or shared) on demand. 
\par Note that you needn't unlock a byte range as many  times as it was locked - only the last lock operation is "active"
\par Note - Changing the locking method of a byte range is not atomic - bytes are releases and then locked again, which makes that another process might take ownership in the meantime.
\par rename lock_chunk -lock_range !!!!
\par \tab - Locks are NEVER shared with child processes, even those born from a simple fork() without exec(). 
\par \tab - fcntl locks are (theoretically) supported by recent enough (>4.???) NFS servers
\par -flock locks:
\par These are advisory, per-open-file, non reentrant?? locks, dealing only with the whole file. 
\par \tab -All handles pointing to the open file table entry on which the flock() call was issued, "own" this lock. It means that different handles in the same process, 
\par 
\par The "flock" affair.
\par At first, a very interesting alternative to fcntl:
\par \tab - locking per-file-table-entry instead of per-process, allowing more isolation inside a process
\par \tab -no loss of locks in case of file desciptor closing
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\outlinelevel0\rin0\lin0\itap0\pararsid6238528 {\f2\fs20\insrsid6238528 But
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\insrsid6238528 \tab -no NFS support
\par \tab -no byte range locking
\par \tab -dulicated/inherited file descriptors share their locks with original  ones
\par \tab -on several platforms, flock locks are actually emulated by fcntl(), and thus don't respect their theoretical semantic
\par Conclusion : not worth the hassle
\par 
\par 
\par Warning - the 
danger with this system, is that your process could run out of available file handles, if it continuely opens and locks the same file(s) without ever letting the possibility to release them - i.e by constantly keeping at least some bytes locked.
\par Blatantly,
 if your application behaves that way, it creates some kind of denial-of-service against any other process which would want to lock the whole file, so it could be the sign that other means of protection (file permissions, immediate deletion of the filesys
tem entry...) would be more appropriate for your needs than record locking. 
\par But if you reaallly need to constantly lock parts of the file (eg. for a shared database file), then you shall
\par - reuse the same file descriptors whenever possible
\par - plan "zero lock" moments to allow the garbage collection of an inode's zombie file descriptors
\par - let the closing operation of a file descriptor atomically release the locks still kept, instead of manually unlocking them just before closing the file. This helps garbage co
llection, by ensuring that no new lock is taken in the short time between the unlocking operation and the closing of the descriptor itself.
\par 
\par 
\par rsfile.umask
\par Sets the permission mask used when creating a new inode, and returns the previous mask. On unix platf
orms, the umask is inherited from the parent process, and features all the flags describe in the stat module ; on windows it is zero on startup, and only the "user write" flag is taken into account, to switch between read-only and normal file.
\par 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\outlinelevel0\rin0\lin0\itap0\pararsid6238528 {\f2\fs20\insrsid6238528 TODO:
\par HOW TO disable the effects of the umask on *nix???
\par DEAL WITH THE STICKY BIT !!! 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\insrsid6238528 Or make win32 like unix, by offering folder permissions and changing file deletion with readonly files!!!!!
\par 
\par rsfile.close_handle
\par Closes the native handle, and performs any cleaning operation required by the rsfile system (currently : nothing).
\par The handle might not be closed immediately.
\par 
\par rsfile.close_fileno
\par Closes the C file descriptor according to the mechanisms of the rsfile syste
m. Currently, it prevents the loss of fcntl locks on unix platfotms, by placing the file descriptor in the garbage collection system (note that this file descriptor might not be closed immediately, thus)
\par 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\outlinelevel0\rin0\lin0\itap0\pararsid6238528 {\f2\fs20\insrsid6238528 HOW TO KNOW THE COUNT OF OPEN FILES FOR CURRENT PROCESS ??
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\insrsid6238528 
\par Warning : the sharing of open file table entries by several handles (via handle duplication, inheritance or unix message passing) is a dangerous sport, since in this case they all share the same file pointer, which opens the doors to memorable rac
e conditions (EVEN WHEN LOCKING??). As long as these handles are in the same process, basic mutexes can suffice to sort it out, but in the interprocess case, it is necessary to agree on a shared lock, which is slightly harder
\par 
\par ===> enforce no reentrancy even in win32 ! ! else deadlocks may occur !!! Raise rruntime error when locking twice !!
\par 
\par DONNER POSSIBILITE DE RECREER FILE OBJECT A PARTIR D'UN MUTEX ou SEMAPHORE AUSSI !!! IPC 
\par -> done
\par 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\outlinelevel0\rin0\lin0\itap0\pararsid6238528 {\f2\fs20\insrsid6238528 VERIFIER : est-ce que les handles sont systemwide ou processwide
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\insrsid6238528 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\outlinelevel0\rin0\lin0\itap0\pararsid6238528 {\f2\fs20\insrsid6238528 DO NOT raise errors when auto unlocking file on close
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\insrsid6238528 
\par y A T IL DIFFERENT ENTRE FLOCK5\'b0 ET PUIS O_SCLOCK de BSD ????
\par 
\par 
\par There is a catastrophic flaw in fcntl lock specifications : when any file descriptor to a disk file is closed, all the locks owned by the p
rocess on that file is lost. Beware : we said "any" file descriptor, not the file descriptor which was used to obtain locks, or one of the file descriptors pointing to the same open file table entry. So if, while you're peacefully playing with your locks 
around some important file (sey, /etc/passwd), one of the numerous libraries used of your project
\par 
\par 
\par It's still unclear why Posix people specified it that way. Rumors affirm that they actually let a monkey write the fcntl part, and later on they un***(inadvertance) let the fruits of this funny experiment go with final specs ; others affirm that one of th
e
 workgroups was unfortunately close from an oenologia session. Anyway, we have to live with this fact : the only unix locks able to work over NFS and to lock byte ranges, are also the only locks in the world able to discreetly run away as soon as they''re
 disturbed by third-party libraries. Impressive, isn't it?
\par 
\par 
\par 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\outlinelevel0\rin0\lin0\itap0\pararsid6238528 {\f2\fs20\insrsid6238528 Related system calls
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\insrsid6238528 
\par sync fsync(), fdatasync(), fcntl(FULLFLUSH????)
\par size 
\par 
\par 
\par 
\par }}