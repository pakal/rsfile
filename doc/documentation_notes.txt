
NT real native API
http://undocumented.ntinternals.net/

By default, Windows caches file data that is read from disks and written to disks.  This implies that read 
operations read file data from an area in system memory known as the system file cache, rather than from the physical disk.

# CRUCIAL PART # :
When caching is disabled (FILE FLAG NO BUFFERING), all read and write operations directly access the physical disk. 
However, the file metadata may still be cached.  To flush the metadata to disk, use the FlushFileBuffers() function.
File system metadata is always cached.  Therefore, to store any metadata changes to disk, 
the file must either be flushed or be opened with FILE_FLAG_WRITE_THROUGH.


GetLongPathName
    Retrieves the long path for a short path (8.3 filename) 
GetFullPathName
    Returns full path for path passed in 



 Warning : giving an integer C file descriptor as wrapped item is very buggy for future file locking ! """

     
"""        
    TO BE  MIMICKED AND REUSED !!!
exception io.BlockingIOError

    Error raised when blocking would occur on a non-blocking stream. It inherits IOError.
    In addition to those of IOError, BlockingIOError has one attribute:
    characters_written¶
        An integer containing the number of characters written to the stream before it blocked.

exception io.UnsupportedOperation¶
    An exception inheriting IOError and ValueError that is raised when an unsupported operation is called on a stream."""        
     
             
        
        
    """
    def _check_chunk_locking_availability(self, slice_start, slice_end):
        # TODO : rendre cela conditionnel selon variables globales 
        global _locked_chunks_registry"""
        #if self._track_locked_chunks = True: # MUST BE INHERITED FROM GLOBAL REGISTRY
        #self._locked_chunks_registry = [] # to keep track of locked parts, and prevent recusrive locking / variable unlocking        
                
                
       """ TODO
        if whence = os.SEEK_SET:
            abs_whence = 0
        elif whence = os.SEEK_CUR:
            abs_whence = self._inner_tell()
        elif whence = os.SEEK_END:
            abs_whence = self._inner_size()
        abs_start = abs_whence+offset if offset else abs_whence
        
        abs_end = abs_start+length if length else None # None means "infinity" here !
        """

    # We just override the messages printed by the errors raised #
    def _checkReadable(self, msg=None):
        RawIOBase._checkReadable(self, "Bad file descriptor - not readable") 
    def _checkWritable(self, msg=None):
        RawIOBase._checkWritable(self, "Bad file descriptor - not writable")  
    # TODO - CHECKTRUNCATABLE ??????????????    def _checkClosed(self, msg=None): # this method checks if the file is well NOT closed !
        RawIOBase._checkClosed(self,"I/O operation on closed file")  

        
                """
        FIND OPEN HANDLES !!!!
        How does it work ?
OpenedFilesView uses the NtQuerySystemInformation API to enumerate all handles 
in the system. After filtering non-file handles, it uses a temporary device driver 
- NirSoftOpenedFilesDriver.sys for reading the information about each handle from 
the kernel memory. This device driver is automatically unloaded from the system when 
you exit from OpenedFilesView utility. 
        
        """
        
        """
        Forsaken attempt : atomic appends on win32 -> no truncation rights... too bad
        if append:
            desiredAccess |= 0x0004 | 0x0100 | 0x0010  # FILE_APPEND_DATA, FILE_WRITE_ATTRIBUTES and FILE_WRITE_EA, but NOT FILE_WRITE_DATA
        """
        

""""


def open(fname, mode="r", bufsize=None): " Like the "open" built-in, but does not inherit to child processes. 
The code is using os.open and os.fdopen. On Windows, to avoid inheritance, os.O_NOINHERIT is used directly in the open call, t
hus it should be thread-safe. On other operating systems, fcntl with FD_CLOEXEC is used right after opening the file; however 
in a mutli-threaded program it may happen that another thread starts a child process in the fraction of a second between os.open and fcntl.

Note: The bufsize argument is ignored (not yet implemented). " flags = 0 if "r" in mode: flags += os.O_RDONLY elif "w" in mode: 
flags += os.O_RDWR + os.O_CREAT + os.O_TRUNC elif "a" in mode: flags += os.O_RDWR + os.O_CREAT + os.O_APPEND else: 
raise NotImplementedError ("mode=" + mode) if os.name == "nt": if "b" in mode: flags += os.O_BINARY else: 
flags += os.O_TEXT flags += os.O_NOINHERIT try: fd = os.open (fname, flags) if os.name != "nt": old = 
fcntl.fcntl(fd, fcntl.F_GETFD) fcntl.fcntl(fd, fcntl.F_SETFD, old | fcntl.FD_CLOEXEC) return os.fdopen (
fd, mode) except OSError, x: raise IOError(x.errno, x.strerror, x.filename) 


http://msdn.microsoft.com/en-us/library/aa363858(VS.85).aspx
CREATEFILE
lpSecurityAttributes [in, optional]
    A pointer to a SECURITY_ATTRIBUTES structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes.
    This parameter can be NULL.
    If this parameter is NULL, the handle returned by CreateFile cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor.
    The lpSecurityDescriptor member of the structure specifies a SECURITY_DESCRIPTOR for a file or device. If this member is NULL, the file or device associated with the returned handle is assigned a default security descriptor.
    CreateFile ignores the lpSecurityDescriptor member when opening an existing file or device, but continues to use the bInheritHandle member.
    The bInheritHandle member of the structure specifies whether the returned handle can be inherited.
    For more information, see the Remarks section.

    SOLUTION :
    The _spawn functions can pass all information about open files, including the translation mode, to the new process. 
    This information is passed in real mode through the C_FILE_INFO entry in the environment. The startup code normally 
    processes this entry and then deletes it from the environment. However, if a _spawn function spawns a non-C process,
    this entry remains in the environment. Printing the environment shows graphics characters in the definition string for
    this entry because the environment information is passed in binary form in real mode. It should not have any other effect 
    on normal operations. In protected mode, the environment information is passed in text form and therefore contains no graphics characters.
    
    
os.fdatasync(fd) !!!!!!!!!!
    Force write of file with filedescriptor fd to disk. Does not force update of metadata. Availability: Unix.
    This function is not available on MacOS. <----



IMPORTANT : 
The MSDN documentation doesn't make it clear at all, but FILE_SHARE_DELETE works with MoveFile() in the same way it does with DeleteFile().
In other words, it gives you Unix-style delete/rename semantics. Even while 
you have the file open, Windows can delete it or rename it right out from under you, but you can keep reading it—your
handle to the file remains valid until you close it.

FILE_FLAG_POSIX_SEMANTICS - DO NOT USE THAT !!!!
Access will occur according to POSIX rules. This includes allowing multiple files with names, differing only in case, for file systems 
that support that naming. Use care when using this 
option, because files created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit Windows.


FILE_FLAG_DELETE_ON_CLOSE
The file is to be deleted immediately after all of its handles are closed, which includes the specified handle and any other open or duplicated handles.
If there are existing open handles to a file, the call fails unless they were all opened with the FILE_SHARE_DELETE share mode.
Subsequent open requests for the file fail, unless the FILE_SHARE_DELETE share mode is specified.


    
FILE_ATTRIBUTE_TEMPORARY - useless
Specifying the FILE_ATTRIBUTE_TEMPORARY attribute causes file systems to avoid writing data back to
mass storage if sufficient cache memory is available, because an application deletes a temporary file
after a handle is closed. In that case, the system can entirely avoid writing the data. Although it doesn't
directly control data caching in the same way as the previously mentioned flags, the FILE_ATTRIBUTE_TEMPORARY
attribute does tell the system to hold as much as possible in the system cache without writing and therefore
may be of concern for certain applications.    
    

    
    # we let the default "repr", like for new io module !
    def __repr__(self):
        return "<%s file %s'%s', mode '%s' at %d>"%(
                "closed" if self.closed else "open",
                "u" if isinstance(self.name, unicode) else "",
                self._name.encode(locale.getpreferredencoding()) if isinstance(self._name, unicode) else str(self._name), # remember it might be a file descriptor !
                str(self._mode),
                id(self._handle)
                )

    def __str__(self):
        return repr(self)   
    """   
    
process explorer sysinternal - cool soft !!

Get name : I think ps is reading from /prod/pid/cmdline which is also truncated. ... Browse other questions tagged linux pid process limits classpath ...


FROM http://www.redhat.com/docs/manuals/linux/RHL-9-Manual/ref-guide/s1-proc-topfiles.html
5.2.17. /proc/locks

This file displays the files currently locked by the kernel. The contents of this file contain internal kernel debugging data and can vary tremendously, depending on the use of the system. A sample /proc/locks file for a lightly loaded system looks similar to this:

1: FLOCK  ADVISORY  WRITE 807 03:05:308731 0 EOF c2a260c0 c025aa48 c2a26120
2: POSIX  ADVISORY  WRITE 708 03:05:308720 0 EOF c2a2611c c2a260c4 c025aa48

Each lock has its own line which starts with a unique number. The second column refers to the class of lock used, with FLOCK signifying the older-style UNIX file locks from a flock system call and POSIX representing the newer POSIX locks from the lockf system call.

The third column can have two values: ADVISORY or MANDATORY. ADVISORY means that the lock 
does not prevent other people from accessing the data; it only prevents other attempts to
 it. MANDATORY means that no other access to the data is permitted while the lock is held. 
 The fourth column reveals whether the lock is allowing the holder READ or WRITE access to 
 
 the file. The fifth column shows the ID of the process holding the lock. The sixth column 
 shows the ID of the file being locked, in the format of MAJOR-DEVICE:MINOR-DEVICE:INODE-NUMBER.
 The seventh column shows the start and end of the file's locked region. The remaining columns 
 point to internal kernel data structures used for specialized debugging and can be ignored.     
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    PYTIME TROUBLES 
    
    
            
            Errors in pywin32 ?
            
            PyWinObject_FromFILETIME(fi.ftCreationTime),
            
        PyObject *PyWinObject_FromFILETIME(const FILETIME &t)
        {
        #ifdef PYWIN_HAVE_DATETIME_CAPI  # TRUE FOR US !!!!!
                // XXX - We should create a datetime object using the localtz here,
                // but for now we only have a utc tz available, so convert to a
                // systemtime and go from there.
                SYSTEMTIME st;
                if (!FileTimeToSystemTime(&t, &st))
                        return PyWin_SetAPIError("FileTimeToSystemTime");
                return PyWinObject_FromSYSTEMTIME(st);
        #endif // PYWIN_HAVE_DATETIME_CAPI
        
        #ifndef NO_PYWINTYPES_TIME
                return new PyTime(t);
        #endif
        }
        
        
        PyObject *PyWinObject_FromSYSTEMTIME(const SYSTEMTIME &t)
        {
        #ifdef PYWIN_HAVE_DATETIME_CAPI
                // SYSTEMTIME structures explicitly use UTC.
                PyObject *obtz = GetTZUTC();
                if (!obtz)
                        return NULL;
                PyObject *ret = PyDateTimeAPI->DateTime_FromDateAndTime(
                                        t.wYear, t.wMonth, t.wDay, t.wHour, t.wMinute,
                                        t.wSecond, t.wMilliseconds*1000,
                                        obtz, &PyWinDateTimeType);
                Py_DECREF(obtz);
                return ret;
        #endif // PYWIN_HAVE_DATETIME_CAPI
        
        #ifndef NO_PYWINTYPES_TIME
                return new PyTime(t);
        #endif
        }
        
        ##### PyDateTimeAPI->DateTime_FromDateAndTime
        /* Create a datetime instance with no range checking. */
static PyObject *
new_datetime_ex(int year, int month, int day, int hour, int minute,
	     int second, int usecond, PyObject *tzinfo, PyTypeObject *type)
{
	PyDateTime_DateTime *self;
	char aware = tzinfo != Py_None;

	self = (PyDateTime_DateTime *) (type->tp_alloc(type, aware));
	if (self != NULL) {
		self->hastzinfo = aware;
		set_date_fields((PyDateTime_Date *)self, year, month, day);
		DATE_SET_HOUR(self, hour);
		DATE_SET_MINUTE(self, minute);
		DATE_SET_SECOND(self, second);
		DATE_SET_MICROSECOND(self, usecond);
		if (aware) {
			Py_INCREF(tzinfo);
			self->tzinfo = tzinfo;
		}
	}
	return (PyObject *)self;
}



        
                // Timezone helpers...
        // Returns a timezone object representing UTC.  Implementation currently
        // calls into win32timezone for an object then caches it forever.
        static PyObject *GetTZUTC()
        {
                static PyObject *got = NULL;
                if (got==NULL) {
                        // assumes we have the gil so no races...
                        PyObject *mod = PyImport_ImportModule("win32timezone");
                        if (!mod)
                                return NULL;
                        PyObject *klass = PyObject_GetAttrString(mod, "TimeZoneInfo");
                        Py_DECREF(mod);
                        if (!klass)
                                return NULL;
                        PyObject *args = PyTuple_New(0);
                        if (args) {
                                got = PyObject_CallMethod(klass, "utc", "");
                                Py_DECREF(args);
                        }
                        Py_DECREF(klass);
                        assert(got);
                        assert(got != Py_None); // this would silently create a tz-naive object.
                }
                Py_XINCREF(got);
                return got;
        }

        
        
        PYTIME.CPP l 496::
        
        tm.tm_mon = st.wMonth - 1;
	tm.tm_year = st.wYear - 1900;
	tm.tm_isdst = -1;	/* have the library figure it out */ <-------- NO ! we're in GMT time !!!
	long result = (long)mktime(&tm);
	if ( result == -1 )
        
        FIX : use SystemTimeToTzSpecificLocalTime Function to not be in GMT !!!
        
        
        NEW VERSION : CF http://sourceforge.net/tracker/index.php?func=detail&aid=2831327&group_id=78018&atid=551954
        PyTime::PyTime(const FILETIME &t)
            {
                    ob_type = &PyTimeType;
                    _Py_NewReference(this);
                    SYSTEMTIME st;
                    m_time = 0;
                    FileTimeToSystemTime(&t, &st);
            
                    SYSTEMTIME lt;
                if (SystemTimeToTzSpecificLocalTime(NULL, &st, &lt))
                    {
                            // what shall we do on error ???  
                    }
            
                    (void)SystemTimeToVariantTime(&lt, &m_time);
            }
                     
            
        I've had a hard time with that bug too :p
The problem is that indeed the current pywin32 implementation uses FileTimeToSystemTime to get an UTC datetime, but then when converting to unix timestamp it uses mktime which expects localtime and automatically guesses the timzone/daylightsaving, so we get wrong values.

Couldn't we just remove the #undef which prevents using python datetime api before py3k ? Or replace FileTimeToSystemTime  by FileTimeToLocalTime and only work with local pytimes, by adding (SystemTimeToTzSpecificLocalTime(NULL, &st, &lt)) after FileTimeToSystemTime(&t, &st); ?
            """
            