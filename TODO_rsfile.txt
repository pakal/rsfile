

Add atfork to rsfile, to warn users

 Add comment in pypi - don't install as egg !!!! 

**{kwargs} problem unicode still somewhere !!
 
   bug in rsfile - bad indentation !!!!!!!!!!!              
                if not isinstance(e.strerror, unicode):
                    strerror = e.strerror.decode(UNIX_MSG_ENCODING, 'replace')
                else:
                    strerror = e.strerror
 
 
# TODO - add tests for bytearray, bytes, array.array and memoryview writing/reading !!!!
# IMPORTANT - sort out issues with bytes, bytearray, memoryview etc !!


SUBMIT PATCH test_fileio:
    @ClosedFDRaises
    def testErrnoOnClosedWrite(self, f):
        f.write(b'a')


C:\Users\Pakal\Desktop\RockSolidTools>C:\Users\Pakal\Desktop\SVN_py3k_branch\PCbuild\python.exe setup.py install
C:\Users\Pakal\Desktop\SVN_py3k_branch\Lib\site-packages>..\..\PCbuild\python.exe rstest\test_rsfile_streams.py


* DOES IO STREAM INHERITANCE WORK VIA PICKLE / MULTITHREADING ???????????
TODO - TEST SEMAPHORE INHERITANCE !!!!!

*Test on all python implementations, versions, on all platforms etc.

TODO - submit bug : no way to reset() C io extension buffers !! 


OPTIMISER READALL() avec join()

#TODO py2.7 the file object will now set the filename attribute on the IOError exception when trying to open a 
directory on POSIX platforms. (Noted by Jan Kaliszewski; issue 4764.)


# TODO - discuss threads in multiprocessing when forking - why not spawn like win32 ??



Hello

Kernel-level file locking is an extremly complex subject, since different types of locks have very different semantic, and the main lock of unix systems (fcntl) has horrible flaws.
But I've just released a python library which deals with the issue in a very portable way. It can achieve shared/exclusive file record locking in a system-wide manner, and provides workaround for fcntl flaws.
Enjoy RSFile - http://bitbucket.org/pchambon/python-rock-solid-tools/

https://www.google.com/accounts/o8/id?id=aitoawnwjnuglfbcjpdjkxg5tqhza7b2uh2ipok

The problem with the code above is that it requires pywin32, it doesn't provide shared/exclusive semantic nor file record locking, and it doesn't deal with the fcntl() flaw (i.e the loss of all locks on a given file when any descriptor to it is closed).
I advise you to use the portable file stream I've created on a basis similar to your code, it offers file locking, disk cache synchonizatio and a whole bunch of cool features (advanced opening flags, stream inheritance management, fcntl workaround etc.)
Besides, it works with py26, py27, py3K, and theoretically with other python implementations (ironpython, jython etc.)
http://bitbucket.org/pchambon/python-rock-solid-tools/


*Add support for sparse files on ntfs (FSCTL_SET_ZERO_DATA, DeviceIoControl(FSCTL_SET_SPARSE))? -> maybe useless, delayed

*How to know the count of open files for current process ? -> useless

*Make inheritable streams picklable for multiprocessing use, along with their semaphores -> long and hard, delayed

*Design a strong exception hierarchy for IO/OS errors - if it is really possible from native error codes -> delayed

*Create a global option registry to activate debugging systems (open handle counting, deadlock detection...) -> delayed


